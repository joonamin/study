[toc]

# Item20. 추상 클래스보다는 인터페이스를 우선하라

추상 클래스와 인터페이스는 `필드와 메서드의 기본 틀을 제공하고 구현은 구체 클래스에게 위임한다는 점`에서 객체지향의 꽃이라고 볼 수 있다. $\rightarrow$ 변경에 유연한 컴포넌트 설계가능



* 자바 8 이전까지는 default method를 지정하려면 무조건 추상 클래스를 이용해야만 했다. $\rightarrow$ 자바8부터는 인터페이스도 default method를 제공할 수 있다.



## 추상 클래스의 한계

* 추상 클래스는 `상속`을 기반으로 하므로, Hierarchical 하다. 하지만, 현실에서는 계층을 구분하기 모호한 경우가 많다.

* 자바에서는 다중 상속에 따른 문제점들을 피하기 위하여, 다중 상속을 금지하였다. 그 결과로, **추상 클래스를 상속받은 구현 클래스는 또 다른 추상 클래스를 상속받지 못한다.**

추후 릴리즈에서 <u>특정 선택적 행위</u>를 추가하고자 할 경우, 이전에 추상클래스를 상속받은 또 다른 추상 클래스를 설계해야한다.  $\rightarrow$ **본질적으로, 믹스인을 삽입하기에 클래스의 계층구조가 합리적이지 않다.**

> 클래스 A와 B가 동일한 추상클래스를 상속받기를 원한다면 계층 구조 상 공통조상이여야한다.
>
> ![abstractClass](https://raw.githubusercontent.com/joonamin/UpicImageRepo/master/uPic/abstractClass.png)
>
> 위 상황에서 A, B가 동일한 추상 클래스를 상속받기 위하여, A는 "특정 선택적 행위"와는 무관한 m, n의 기능을 포함하게 된다.
>
> 이러한 상황을 피하기 위해서 타입을 계층적으로 잘 표현하기 위해 가능한 조합만큼 계층구조를 만드는데 필요한 노드의 개수는 $2^n$ 이다. (조합 폭발)



## 추상 클래스의 장점 및 인터페이스의 한계

* ⁉️ 많은 인터페이스가 equals와 hashcode같은 Object의 메소드를 정의하고 있지만, 이들은 디폴트 메소드로 제공해서는 안된다. (~~이게 무슨 소릴까? 왜?)~~
* `상속`을 기반으로 하기 때문에, 기능의 재정의가 편리하다. (우리가 만들지 않은 추상 클래스에도 디폴트 메소드를 추가할 수 있다.)
* 추상 클래스에는 **public, protected, private 메소드를 가질 수 있는** 반면에 인터페이스는 public, private static만 허용된다.
* 추상 클래스에는 **멤버변수 선언이 가능**하지만 인터페이스는 public static 변수만 선언이 가능하다.





## 인터페이스의 장점

* 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다. (믹스인)
* 인터페이스는 믹스인 정의에 안성맞춤이다.
* 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
* 래퍼 클래스 관용구(아이템 18)과 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.





## 인터페이스의 장점 + 추상클래스의 장점을 결합한 방식

앞서 살펴보았듯, 인터페이스는 자바8 부터 디폴트 메소드를 지원하지만 제약이 존재한다.

실행과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 `템플릿 메서드` 패턴을 사용할 수 있다.

템플릿 메서드 패턴을 사용할 경우, 인터페이스의 장점과 추상 클래스의 장점을 결합하여 설계할 수 있다.



* 인터페이스로 타입을 정의한다. (필요에 따라 default method 제공)
* 추상 골격 구현(skeletal implementation) 클래스를 함께 제공한다. 앞에서 정의하지 못한 default method를 구현한 클래스를 정의한다. (관습상, `Abstract` 접두사로 명명한다고 한다.)



템플릿 메서드 패턴에서는 상위 타입의 템플릿 메소드가 모든 실행 흐름을 제어하고 하위 타입의 메서드는 템플릿 메서드에서 호출되는 구조를 갖게된다.

1. 실행 과정을 구현한 상위 클래스 (인터페이스 또는 추상 클래스) 

$\rightarrow$ 어쨌거나 A, B, C 순서대로 실행은 되지만, A,B,C의 각각의 세부 구현은 다를 수 있다.

$\rightarrow$ 기본적인 동작은 default method에 정의한다.



2. 실행 과정의 일부 단계를 구현한 하위 클래스

$\rightarrow$ A, B, C 각각의 기능은 구현 클래스마다 유동적이다.



ex)  `AbstractMap` - 추상 클래스

```java
public abstract class AbstractMap<K, V> {
   public V get(Object key) {
    Iterator<Entry<K,V>> i = entrySet().iterator();
    if (key==null) {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (e.getKey()==null)
                return e.getValue();
        }
    } else {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (key.equals(e.getKey()))
                return e.getValue();
        }
    }
    return null;
	}
}
```



ex2) `HashMap` - 구체 클래스

```java
public V get(Object key) {
    Node<K, V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
```

ex3) `TreeSet` - 구체 클래스

```java
public V get(Object key) {
    Entry<K, V> p = getEntry(key);
    return (p == null ? null : p.value);
}
```



`get()` 과 같이 하위 클래스에서 재정의할 수 있는 메소드를 `hook` 메소드라고 한다.



---

## 템플릿 메소드 패턴을 적용할 때 `추상 클래스`를 사용할까? `인터페이스` 를 사용할까?

hook 메소드든 추상메소드든 그 메소드들이 실행되는 순서가 중요할 수 있다. 그래서 템플릿 메소드를 만들고 그 안에 어떤 메소드들을 순서에 맞게 호출해 두었다고 치자.



이때, 템플릿 메소드 내부에서 사용되는 메소드들에 대한 (구현은 하위클래스에서 하고) 외부에서의 호출을 막고 싶다면 추상클래스로 사용하는게 맞는 것 같다. 추상클래스를 사용하면 protected, private 제어자를 지정할 수 있기 때문이다. (추상클래스가 같은 패키지 내에 있다면 protected 라도 접근 가능하지만, 템플릿메소드패턴이 적용된 추상클래스는 라이브러리 형태로 외부패키지에서 제공되는 방식일 것이므로, 상속을 받지 않은 클래스에서는 호출하지 못하게 할 수 있다고 봐도 될 것 같다)

**인터페이스는 기본적으로 변수필드는 public static final 이며, 모든 메소드는 public abstract 이므로 인터페이스로 구현할 경우, 템플릿 메소드 내부에서만 호출되어야 할 메소드들이 public 제어자에 의해 의도치 않은 사용처에서 호출될 위험이 있다.**

이때 또 생각해야 할 것은, 자바는 다중상속을 허용하지 않기 때문에 템플릿 메소드 패턴이 적용된 추상클래스를 구현한 서브클래스는 다른 클래스를 상속받을 수 없다는 단점이 있다. 반면, 인터페이스로 템플릿 메소드 패턴을 구현했다면 다른 클래스를 상속 받을 수 있는 가능성을 열어둘 수 있다.

그러면 자바의 AbstractMap, AbstractSet 등은 왜 인터페이스가 아닌 추상클래스로 선언된 것일까? 이건 딱히 무슨 대단한 이유가 있다기 보다는… 자바8 이전에 인터페이스는 구현체를 가질 수 없었기 때문이다.

무엇이든 장단점이 있고, 항상 그렇듯 정답은 없는 것 같다.

